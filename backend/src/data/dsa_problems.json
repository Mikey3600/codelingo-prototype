[
  {
    "id": "dsa-arrays-1",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "difficulty": "easy",
    "category": "Arrays",
    "codeTemplates": {
      "python": "def two_sum(nums, target):\n    # Your code here\n    pass",
      "javascript": "function twoSum(nums, target) {\n    // Your code here\n}",
      "java": "public class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // Your code here\n        return new int[]{0, 0};\n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Your code here\n        return {0, 0};\n    }\n};"
    },
    "testCases": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "expectedOutput": "[0, 1]",
        "isHidden": false
      },
      {
        "input": "nums = [3, 2, 4], target = 6",
        "expectedOutput": "[1, 2]",
        "isHidden": false
      },
      {
        "input": "nums = [3, 3], target = 6",
        "expectedOutput": "[0, 1]",
        "isHidden": false
      },
      {
        "input": "nums = [1, 5, 8, 3, 9, 2], target = 7",
        "expectedOutput": "[0, 5]",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider using a hash map to store values you've seen so far",
      "For each element, check if target - current element exists in the hash map",
      "Time complexity should be O(n) where n is the length of the array"
    ],
    "solution": {
      "python": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
      "javascript": "function twoSum(nums, target) {\n    const seen = {};\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (complement in seen) {\n            return [seen[complement], i];\n        }\n        seen[nums[i]] = i;\n    }\n    return [];\n}",
      "java": "public class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (map.count(complement)) {\n                return {map[complement], i};\n            }\n            map[nums[i]] = i;\n        }\n        return {};\n    }\n};"
    },
    "xpReward": 20,
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "dsa-arrays-2",
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "difficulty": "medium",
    "category": "Arrays",
    "codeTemplates": {
      "python": "def max_subarray(nums):\n    # Your code here\n    pass",
      "javascript": "function maxSubArray(nums) {\n    // Your code here\n}",
      "java": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        // Your code here\n        return 0;\n    }\n};"
    },
    "testCases": [
      {
        "input": "nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "expectedOutput": "6",
        "isHidden": false
      },
      {
        "input": "nums = [1]",
        "expectedOutput": "1",
        "isHidden": false
      },
      {
        "input": "nums = [5, 4, -1, 7, 8]",
        "expectedOutput": "23",
        "isHidden": false
      },
      {
        "input": "nums = [-1, -2, -3, -4]",
        "expectedOutput": "-1",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider using Kadane's algorithm",
      "Keep track of the current sum and the maximum sum seen so far",
      "If the current sum becomes negative, reset it to zero"
    ],
    "solution": {
      "python": "def max_subarray(nums):\n    current_sum = max_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
      "javascript": "function maxSubArray(nums) {\n    let currentSum = nums[0];\n    let maxSum = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    return maxSum;\n}",
      "java": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        int currentSum = nums[0];\n        int maxSum = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int currentSum = nums[0];\n        int maxSum = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            currentSum = max(nums[i], currentSum + nums[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n};"
    },
    "xpReward": 30,
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "dsa-linked-list-1",
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "difficulty": "easy",
    "category": "Linked Lists",
    "codeTemplates": {
      "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverse_list(head):\n    # Your code here\n    pass",
      "javascript": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nfunction reverseList(head) {\n    // Your code here\n}",
      "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\npublic class Solution {\n    public ListNode reverseList(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
      "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n};"
    },
    "testCases": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "expectedOutput": "[5, 4, 3, 2, 1]",
        "isHidden": false
      },
      {
        "input": "head = [1, 2]",
        "expectedOutput": "[2, 1]",
        "isHidden": false
      },
      {
        "input": "head = []",
        "expectedOutput": "[]",
        "isHidden": false
      }
    ],
    "hints": [
      "Use three pointers: previous, current, and next",
      "Iterate through the list, changing the next pointer of each node",
      "Be careful not to lose the reference to the next node"
    ],
    "solution": {
      "python": "def reverse_list(head):\n    prev = None\n    current = head\n    while current:\n        next_temp = current.next\n        current.next = prev\n        prev = current\n        current = next_temp\n    return prev",
      "javascript": "function reverseList(head) {\n    let prev = null;\n    let current = head;\n    while (current !== null) {\n        const nextTemp = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    return prev;\n}",
      "java": "public class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode nextTemp = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        return prev;\n    }\n}",
      "cpp": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        while (current != nullptr) {\n            ListNode* nextTemp = current->next;\n            current->next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        return prev;\n    }\n};"
    },
    "xpReward": 25,
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  }
]